#ifndef _TASK_HH
#define _TASK_HH

// Prevent compilation errors using the define below. The Windows port of FreeRTOS includes <windows.h> 
// which causes problems with some legacy 980 source code.
// "Define WIN32_LEAN_AND_MEAN to exclude APIs such as Cryptography, DDE, RPC, Shell, and Windows Sockets."
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "Sigma.hh"
#include "TaskId.hh"
#include "xmap.hh"
#include "xlist.hh"
#include "xallocator.hh"
#include "Platform.hh"
#include "TaskBase.hh"
#include "MutEx.hh"
#include "FreeRTOS.h"
#include "task.h"
#include "PlatformUndef.hh"
#include <memory>
#include "TaskInfo.hh"

// Thread entry function
typedef void (*TaskEntryFunc)(...);

typedef TaskHandle_t OsTask;

class TaskInfo;

class Task
{
public:
    static const int MAX_NUM_TASKS = 100;

    /// Constructor
    Task(const char* threadName);

    /// Destructor
    ~Task();

    static void Initialize(void);

    /// Called once to create the worker thread
    /// @return True if thread is created. False otherwise. 
    bool Create(TaskEntryFunc func, Int taskId);

    /// Called once a program exit to exit the worker thread
    void Exit();

    /// Get the ID of this thread instance
    /// @return The worker thread ID
    OsTaskId GetOsTaskId() const;

    /// Get the ID of the currently executing thread
    /// @return The current thread ID
    static OsTaskId GetActiveOsTaskId();

    Int GetTaskId();

    static Int GetActiveTaskId(bool noFail = false);

    static void Delay(const Uint32 sec, const Uint32 mils = 0);

    static void Yield(void);

    static void SetTasksCreated(void) { m_tasksCreated = true; }
    static bool IsTaskingOn(void);

    static bool IsTasksCreated(void);

    static TaskInfo& GetTaskInfo(const Int32 taskId);

    static TaskInfo& GetTaskInfo(const TaskId taskId);

    static Int GetTaskCount() { return m_taskCount; }

    TaskState GetTaskState();

    void SetTaskPriority(Int priority);

    Int GetTaskPriority();

    void GetTaskPerformance(xstring& pcTaskName, TaskState& taskState, Int32& priority, uint64_t& runCount);

private:
    Task(const Task&) = delete;
    Task& operator=(const Task&) = delete;

    TaskState convertState(eTaskState taskState);

    OsTask m_osTask;
    const char* THREAD_NAME;

    static MutEx m_mutex;

    static Int m_taskCount;

    static bool m_initialized;
    static bool m_taskingOn;
    static bool m_tasksCreated;

    static xmap<Int32, TaskInfo*> m_taskInfoMap;
    static xmap<TaskId, TaskInfo*> m_taskInfoMap2;
    static xmap<OsTaskId, Int> m_osTaskIdToTaskIdMap;

    static xlist <std::shared_ptr<StaticTask_t>> m_tcbList;

    XALLOC_NEW_DELETE
    SOFT_FAULT_DEFN();
};

#endif 

