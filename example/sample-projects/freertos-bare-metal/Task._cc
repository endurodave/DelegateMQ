#include "Task.hh"
#include "TaskTable.hh"
#include "TaskInfo.hh"
#include "FaultHandlerMacros.hh"
#include "OsFoundation.hh"
#include "xmap.hh"
#include <string.h>
#include "PlatformUndef.hh"
#include "Trace.hh"
#include "FreeRTOS.h"

using namespace std;

Int Task::m_taskCount = 0;
xmap<Int32, TaskInfo*> Task::m_taskInfoMap;
xmap<TaskId, TaskInfo*> Task::m_taskInfoMap2;
xmap<OsTaskId, Int> Task::m_osTaskIdToTaskIdMap;
xlist<std::shared_ptr<StaticTask_t>> Task::m_tcbList;
bool Task::m_initialized = false;
bool Task::m_taskingOn = false;
bool Task::m_tasksCreated = false;
MutEx Task::m_mutex(TASK_MT);

#define MUTEX_LOCK MutExLock mutexLock(m_mutex);

//----------------------------------------------------------------------------
// Task
//----------------------------------------------------------------------------
Task::Task(const char* threadName) : m_osTask(nullptr), THREAD_NAME(threadName)
{
}

//----------------------------------------------------------------------------
// ~Task
//----------------------------------------------------------------------------
Task::~Task()
{
	Exit();
}

//----------------------------------------------------------------------------
// Initialize
//----------------------------------------------------------------------------
void Task::Initialize(void)
{
    CLASS_PRE_CONDITION(Task::IsTaskingOn() == FALSE);
    CLASS_PRE_CONDITION(Task::m_initialized == false);
    //ERM CLASS_PRE_CONDITION( TaskTable::IsInitialized() );
    //SAFE_CLASS_ASSERTION((sizeof(::TaskInfoMemory)
    //    >= (sizeof(Task) * (Task::MAX_NUM_TASKS + 1))));

    // Create a Task object for each potential task
    for (Int32 tid = 1; tid <= TaskTable::GetNumEntries(); tid++)
    {
        TaskInfo* taskInfo = new TaskInfo(tid, TaskTable::GetTaskTableEntry(tid));
        CLASS_ASSERTION(taskInfo);

        m_taskInfoMap[tid] = taskInfo;

        TaskId tid2 = taskInfo->getTaskId();
        if (tid2 != TaskId::UNASSIGNED)
            m_taskInfoMap2[tid2] = taskInfo;

        ++m_taskCount;
    }

    Task::m_initialized = true;	// $[TI1]
    Task::m_taskingOn = true;
}

//----------------------------------------------------------------------------
// Create
//----------------------------------------------------------------------------
bool Task::Create(TaskEntryFunc func, Int taskId)
{
    if (!m_osTask)
    {
        auto tcb = std::make_shared<StaticTask_t>();
        CLASS_ASSERTION(tcb != nullptr);
        m_tcbList.push_back(tcb);

        Int32 priority = 0;
        TaskInfo* taskInfo = m_taskInfoMap[taskId];
        if (taskInfo)
        {
            priority = taskInfo->getBasePriority();

            if (priority >= configMAX_PRIORITIES)
            {
                dout << std::dec << "WARNING: Task priority level clipped! " << taskId << std::endl;
                priority = configMAX_PRIORITIES - 1;
            }

            // Create a named worker thread
            m_osTask = xTaskCreateStatic((TaskFunction_t)func,
                taskInfo->getName(),
                taskInfo->getStackSize() / sizeof(StackType_t),
                NULL,
                (UBaseType_t)priority,// | portPRIVILEGE_BIT,
                (StackType_t*)taskInfo->getStack(),
                tcb.get());
            CLASS_ASSERTION(m_osTask != nullptr);

            // Map the thread ID to a task ID
            m_osTaskIdToTaskIdMap[GetOsTaskId()] = taskId;
        }
        else
        {
            // Create a default worker thread
            BaseType_t xReturn = xTaskCreate((TaskFunction_t)func,
                "Default",
                4096,
                NULL,
                configMAX_PRIORITIES - 1,// | portPRIVILEGE_BIT,
                &m_osTask);
            CLASS_ASSERTION(xReturn == pdPASS);
        }
    }

    m_tasksCreated = true;
	return true;
}

//----------------------------------------------------------------------------
// GetOsTaskId
//----------------------------------------------------------------------------
OsTaskId Task::GetOsTaskId() const
{
	CLASS_ASSERTION(m_osTask != nullptr);
	return (OsTaskId)m_osTask;
}

//----------------------------------------------------------------------------
// GetActiveOsTaskId
//----------------------------------------------------------------------------
OsTaskId Task::GetActiveOsTaskId()
{
    OsTaskId id = (OsTaskId)xTaskGetCurrentTaskHandle();
	return id;
}

//----------------------------------------------------------------------------
// GetTaskId
//----------------------------------------------------------------------------
Int Task::GetTaskId()
{
    MUTEX_LOCK
    CLASS_ASSERTION(m_osTaskIdToTaskIdMap.count(GetOsTaskId()) == 1);
    return m_osTaskIdToTaskIdMap[GetOsTaskId()];
}

//----------------------------------------------------------------------------
// GetActiveTaskId
//----------------------------------------------------------------------------
Int Task::GetActiveTaskId(bool noFail)
{
    MUTEX_LOCK
	if (noFail)
    {
        if (m_osTaskIdToTaskIdMap.count(GetActiveOsTaskId()) != 1)
            return -1;
    }
    CLASS_ASSERTION(m_osTaskIdToTaskIdMap.count(GetActiveOsTaskId()) == 1);
    return m_osTaskIdToTaskIdMap[GetActiveOsTaskId()];
}

//----------------------------------------------------------------------------
// Exit
//----------------------------------------------------------------------------
void Task::Exit()
{
    // Can't exit FreeRTOS task
    CLASS_ASSERTION_FAILURE();
}

//----------------------------------------------------------------------------
// SetTaskPriority
//----------------------------------------------------------------------------
void Task::SetTaskPriority(Int priority)
{
    // Can't dynamically set FreeRTOS task priority
    CLASS_ASSERTION_FAILURE();
}

//----------------------------------------------------------------------------
// IsTaskingOn
//----------------------------------------------------------------------------
bool Task::IsTaskingOn(void)
{
    return m_taskingOn;
}

//----------------------------------------------------------------------------
// IsTasksCreated
//----------------------------------------------------------------------------
bool Task::IsTasksCreated(void)
{
    return m_tasksCreated;
}


//----------------------------------------------------------------------------
// Delay
//----------------------------------------------------------------------------
void Task::Delay(const Uint32 seconds, const Uint32 mils)
{
    CLASS_PRE_CONDITION(Task::IsTaskingOn());

    // Is FreeRTOS running?
    if (xTaskGetCurrentTaskHandle())
    {
        // TODO - vTaskDelay in tick, not mS. Fix. 
        TickType_t delay = (seconds * 1000) + mils;
        vTaskDelay(delay);
    }
    else
    {
#ifdef PLATFORM_FREERTOS_WINDOWS
        try
        {
            auto sleepTime = std::chrono::duration<int, std::milli>(mils) +
                std::chrono::duration<int>(seconds);
            std::this_thread::sleep_for(sleepTime);
        }
        catch (std::exception)
        {
            CLASS_ASSERTION_FAILURE();
        }
#else
		// STM32_TODO - need delay before OS starts
        CLASS_ASSERTION_FAILURE();       
#endif
    }
}

//----------------------------------------------------------------------------
// Yield
//----------------------------------------------------------------------------
void Task::Yield(void)
{
    taskYIELD();
}

//----------------------------------------------------------------------------
// GetTaskInfo
//----------------------------------------------------------------------------
TaskInfo& Task::GetTaskInfo(const Int32 taskId)
{
    MUTEX_LOCK
    CLASS_ASSERTION(m_taskInfoMap.count(taskId) == 1);    
    return *m_taskInfoMap[taskId];
}

//----------------------------------------------------------------------------
// GetTaskInfo
//----------------------------------------------------------------------------
TaskInfo& Task::GetTaskInfo(const TaskId taskId)
{
    MUTEX_LOCK
    // If this assertion fails, see TaskTableDef.cc and the the TaskTable entry
    // for the task might need an extra trailing parameter (e.g. TaskId::CONNECTIVITY).
    CLASS_ASSERTION(m_taskInfoMap2.count(taskId) == 1);
    return *m_taskInfoMap2[taskId];
}

//----------------------------------------------------------------------------
// GetTaskInfo
//----------------------------------------------------------------------------
TaskState Task::GetTaskState()
{
    eTaskState taskState = eTaskGetState(m_osTask);  
    return convertState(taskState);
}

Int Task::GetTaskPriority() {

    // Get the priority of the current task
    // UBaseType_t currentPriority = uxTaskPriorityGet(NULL);

    return uxTaskPriorityGet(m_osTask);
}

void Task::GetTaskPerformance(xstring& pcTaskName, TaskState& taskState, Int32&  priority, uint64_t& runCount)
{
    TaskStatus_t pxTaskStatus;
    vTaskGetInfo(m_osTask, &pxTaskStatus, pdTRUE, eRunning);

    //Updating out args
    pcTaskName = pxTaskStatus.pcTaskName;
    taskState = convertState(pxTaskStatus.eCurrentState);
    priority = pxTaskStatus.uxCurrentPriority;
    runCount = pxTaskStatus.ulRunTimeCounter;
}

TaskState Task::convertState(eTaskState taskState)
{
    switch (taskState) {
    case eRunning:
        return TASK_RUNNING;
    case eReady:
        // TBD:: Need to add TASK_READY
        return TASK_READY;
        break;
    case eBlocked:
        // TBD:: Need to add TASK_BLOCKED
        return TASK_BLOCKED;
    case eSuspended:
        return TASK_SUSPENDED;
    case eDeleted:
        return TASK_DELETED;
    default:
        return TASK_ASSERT_FAILED;
    }
}

//------------------------------------------------------------------------------
// SOFT_FAULT_IMPL
//------------------------------------------------------------------------------
SOFT_FAULT_IMPL(Task, OS_FOUNDATION, OsFoundation::TASK);

