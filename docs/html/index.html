<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DelegateMQ: DelegateMQ</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DelegateMQ
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">DelegateMQ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__r_e_a_d_m_e"></a> <img src="docs/DelegateMQ2.jpg" alt="DelegateMQ Layer Diagram" style="width:100%;" class="inline"/><br  />
</p>
<p><img src="https://img.shields.io/github/license/BehaviorTree/BehaviorTree.CPP?color=blue" alt="License MIT" class="inline"/> <a href="https://github.com/endurodave/DelegateMQ/actions/workflows/cmake_ubuntu.yml"><img src="https://github.com/endurodave/DelegateMQ/actions/workflows/cmake_ubuntu.yml/badge.svg" alt="conan Ubuntu" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/endurodave/DelegateMQ/actions/workflows/cmake_clang.yml"><img src="https://github.com/endurodave/DelegateMQ/actions/workflows/cmake_clang.yml/badge.svg" alt="conan Clang" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/endurodave/DelegateMQ/actions/workflows/cmake_windows.yml"><img src="https://github.com/endurodave/DelegateMQ/actions/workflows/cmake_windows.yml/badge.svg" alt="conan Windows" style="pointer-events: none;" class="inline"/></a> <a href="https://app.codecov.io/gh/endurodave/DelegateMQ"><img src="https://codecov.io/gh/endurodave/DelegateMQ/branch/master/graph/badge.svg" alt="Codecov" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
Delegates in C++</h1>
<p>DelegateMQ is a C++ header-only library for invoking any callable (e.g., function, method, lambda):</p>
<ul>
<li>Synchronously</li>
<li>Asynchronously</li>
<li>Remotely across processes or processors</li>
</ul>
<p>It unifies function calls across threads or systems via a simple delegate interface. DelegateMQ is thread-safe, unit-tested, and easy to port to any platform.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Key Concepts</h1>
<ul>
<li><code>MakeDelegate</code> – Creates a delegate instance bound to a callable (lambda, function, or method).</li>
<li><code>MulticastDelegateSafe</code> – A thread-safe container of delegates, allowing broadcast-style invocation.</li>
<li><code><a class="el" href="class_thread.html" title="Cross-platform thread for any system supporting C++11 std::thread (e.g. Windows, Linux).">Thread</a></code> – A cross-platform thread class capable of asynchronous delegate invocation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Examples</h1>
<p>Invoke <code>MsgOut()</code> using delegates.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_delegate_m_q_8h.html">DelegateMQ.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> MsgOut(<span class="keyword">const</span> std::string&amp; msg)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> msg.size();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Examples to create and invoke sync, async and remote delegates</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_thread.html">Thread</a> thread(<span class="stringliteral">&quot;WorkerThread&quot;</span>);</div>
<div class="line">    thread.CreateThread();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> sync = <a class="code hl_function" href="namespacedmq.html#a65e308cc5f3e37d2f7f89c72b9744ae2">dmq::MakeDelegate</a>(&amp;MsgOut);</div>
<div class="line">    sync(<span class="stringliteral">&quot;Invoke MsgOut sync!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> async = <a class="code hl_function" href="namespacedmq.html#a65e308cc5f3e37d2f7f89c72b9744ae2">dmq::MakeDelegate</a>(&amp;MsgOut, thread);</div>
<div class="line">    async(<span class="stringliteral">&quot;Invoke MsgOut async (non-blocking)!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> asyncWait = <a class="code hl_function" href="namespacedmq.html#a65e308cc5f3e37d2f7f89c72b9744ae2">dmq::MakeDelegate</a>(&amp;MsgOut, thread, <a class="code hl_variable" href="namespacedmq.html#a13a5bc30242a3c91cf0cc744e863ffca">dmq::WAIT_INFINITE</a>);</div>
<div class="line">    <span class="keywordtype">size_t</span> size = asyncWait(<span class="stringliteral">&quot;Invoke MsgOut async wait (blocking)!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> asyncWait1s = <a class="code hl_function" href="namespacedmq.html#a65e308cc5f3e37d2f7f89c72b9744ae2">dmq::MakeDelegate</a>(&amp;MsgOut, thread, std::chrono::seconds(1));</div>
<div class="line">    <span class="keyword">auto</span> retVal = asyncWait1s.AsyncInvoke(<span class="stringliteral">&quot;Invoke MsgOut async wait (blocking max 1s)!&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (retVal.has_value())     <span class="comment">// Async invoke completed within 1 second?</span></div>
<div class="line">        size = retVal.value();  <span class="comment">// Get return value</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create remote delegate support objects</span></div>
<div class="line">    std::ostringstream stream(std::ios::out | std::ios::binary);</div>
<div class="line">    <a class="code hl_class" href="class_dispatcher.html">Dispatcher</a> dispatcher;</div>
<div class="line">    <a class="code hl_struct" href="struct_serializer.html">Serializer</a>&lt;void(<span class="keyword">const</span> std::string&amp;)&gt; serializer;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Configure remote delegate</span></div>
<div class="line">    <a class="code hl_struct" href="structdmq_1_1_delegate_free_remote.html">dmq::DelegateFreeRemote</a>&lt;void(<span class="keyword">const</span> std::string&amp;)&gt; remote(<a class="code hl_typedef" href="namespacedmq.html#a5c5e55328ae2cd1d800dfb6c83a21bda">dmq::DelegateRemoteId</a>(1));</div>
<div class="line">    remote.SetStream(&amp;stream);</div>
<div class="line">    remote.SetDispatcher(&amp;dispatcher);</div>
<div class="line">    remote.SetSerializer(&amp;serializer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Invoke remote delegate</span></div>
<div class="line">    remote(<span class="stringliteral">&quot;Invoke MsgOut remote!&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_delegate_m_q_8h_html"><div class="ttname"><a href="_delegate_m_q_8h.html">DelegateMQ.h</a></div><div class="ttdoc">DelegateMQ.h is a single include to obtain all delegate functionality.</div></div>
<div class="ttc" id="aclass_dispatcher_html"><div class="ttname"><a href="class_dispatcher.html">Dispatcher</a></div><div class="ttdoc">Dispatcher sends data to the transport for transmission to the endpoint.</div><div class="ttdef"><b>Definition</b> Dispatcher.h:18</div></div>
<div class="ttc" id="aclass_thread_html"><div class="ttname"><a href="class_thread.html">Thread</a></div><div class="ttdoc">Cross-platform thread for any system supporting C++11 std::thread (e.g. Windows, Linux).</div><div class="ttdef"><b>Definition</b> freertos/Thread.h:24</div></div>
<div class="ttc" id="anamespacedmq_html_a13a5bc30242a3c91cf0cc744e863ffca"><div class="ttname"><a href="namespacedmq.html#a13a5bc30242a3c91cf0cc744e863ffca">dmq::WAIT_INFINITE</a></div><div class="ttdeci">constexpr auto WAIT_INFINITE</div><div class="ttdef"><b>Definition</b> DelegateAsyncWait.h:67</div></div>
<div class="ttc" id="anamespacedmq_html_a5c5e55328ae2cd1d800dfb6c83a21bda"><div class="ttname"><a href="namespacedmq.html#a5c5e55328ae2cd1d800dfb6c83a21bda">dmq::DelegateRemoteId</a></div><div class="ttdeci">uint16_t DelegateRemoteId</div><div class="ttdef"><b>Definition</b> IDispatcher.h:12</div></div>
<div class="ttc" id="anamespacedmq_html_a65e308cc5f3e37d2f7f89c72b9744ae2"><div class="ttname"><a href="namespacedmq.html#a65e308cc5f3e37d2f7f89c72b9744ae2">dmq::MakeDelegate</a></div><div class="ttdeci">auto MakeDelegate(RetType(*func)(Args... args))</div><div class="ttdoc">Creates a delegate that binds to a free function.</div><div class="ttdef"><b>Definition</b> Delegate.h:818</div></div>
<div class="ttc" id="astruct_serializer_html"><div class="ttname"><a href="struct_serializer.html">Serializer</a></div><div class="ttdef"><b>Definition</b> bitsery/Serializer.h:24</div></div>
<div class="ttc" id="astructdmq_1_1_delegate_free_remote_html"><div class="ttname"><a href="structdmq_1_1_delegate_free_remote.html">dmq::DelegateFreeRemote</a></div><div class="ttdef"><b>Definition</b> DelegateRemote.h:132</div></div>
</div><!-- fragment --><p><code>Subscriber</code> registers with <code>Publisher</code> to receive asynchronous callbacks.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Publisher</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Thread-safe container to store registered callbacks</span></div>
<div class="line">    <a class="code hl_struct" href="structdmq_1_1_multicast_delegate_safe.html">dmq::MulticastDelegateSafe</a>&lt;void(<span class="keyword">const</span> std::string&amp; msg)&gt; MsgCb;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> Publisher&amp; Instance() </div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">static</span> Publisher instance;</div>
<div class="line">        <span class="keywordflow">return</span> instance;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> SetMsg(<span class="keyword">const</span> std::string&amp; msg) </div>
<div class="line">    {</div>
<div class="line">        m_msg = msg;    <span class="comment">// Store message</span></div>
<div class="line">        MsgCb(m_msg);   <span class="comment">// Invoke all registered callbacks</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Publisher() = <span class="keywordflow">default</span>;</div>
<div class="line">    std::string m_msg;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Subscriber</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Subscriber() : m_thread(<span class="stringliteral">&quot;SubscriberThread&quot;</span>) </div>
<div class="line">    {</div>
<div class="line">        m_thread.CreateThread();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Register for publisher async callback on m_thread context</span></div>
<div class="line">        Publisher::Instance().MsgCb += <a class="code hl_function" href="namespacedmq.html#a65e308cc5f3e37d2f7f89c72b9744ae2">dmq::MakeDelegate</a>(<span class="keyword">this</span>, &amp;Subscriber::HandleMsgCb, m_thread);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Handle publisher callback on m_thread</span></div>
<div class="line">    <span class="keywordtype">void</span> HandleMsgCb(<span class="keyword">const</span> std::string&amp; msg) { std::cout &lt;&lt; msg &lt;&lt; std::endl; }</div>
<div class="line">    <a class="code hl_class" href="class_thread.html">Thread</a> m_thread;</div>
<div class="line">};</div>
<div class="ttc" id="astructdmq_1_1_multicast_delegate_safe_html"><div class="ttname"><a href="structdmq_1_1_multicast_delegate_safe.html">dmq::MulticastDelegateSafe</a></div><div class="ttdef"><b>Definition</b> MulticastDelegateSafe.h:14</div></div>
</div><!-- fragment --><p>Multiple callables targets stored and invoked asynchronously.</p>
<div class="fragment"><div class="line"><span class="comment">// Create an async delegate targeting lambda on thread1</span></div>
<div class="line"><span class="keyword">auto</span> lambda = [](<span class="keywordtype">int</span> i) { std::cout &lt;&lt; i; };</div>
<div class="line"><span class="keyword">auto</span> lambdaDelegate = <a class="code hl_function" href="namespacedmq.html#a65e308cc5f3e37d2f7f89c72b9744ae2">dmq::MakeDelegate</a>(std::function(lambda), thread1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an async delegate targeting Class::Func() on thread2</span></div>
<div class="line">Class myClass;</div>
<div class="line"><span class="keyword">auto</span> memberDelegate = <a class="code hl_function" href="namespacedmq.html#a65e308cc5f3e37d2f7f89c72b9744ae2">dmq::MakeDelegate</a>(&amp;myClass, &amp;Class::Func, thread2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a thread-safe delegate container</span></div>
<div class="line"><a class="code hl_struct" href="structdmq_1_1_multicast_delegate_safe.html">dmq::MulticastDelegateSafe</a>&lt;void(<span class="keywordtype">int</span>)&gt; delegates;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Insert delegates into the container </span></div>
<div class="line">delegates += lambdaDelegate;</div>
<div class="line">delegates += memberDelegate;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Invoke all callable targets asynchronously </span></div>
<div class="line">delegates(123);</div>
</div><!-- fragment --><p>Asynchronous public API reinvokes <code>StoreAsync()</code> call onto the internal <code>m_thread</code> context.</p>
<div class="fragment"><div class="line"><span class="comment">// Store data using asynchronous public API. Class is thread-safe.</span></div>
<div class="line"><span class="keyword">class </span>DataStore</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DataStore() : m_thread(<span class="stringliteral">&quot;DataStoreThread&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        m_thread.CreateThread();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Store data asynchronously on m_thread context (non-blocking)</span></div>
<div class="line">    <span class="keywordtype">void</span> StoreAsync(<span class="keyword">const</span> Data&amp; data)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// If the caller thread is not the internal thread, reinvoke this function </span></div>
<div class="line">        <span class="comment">// asynchronously on the internal thread to ensure thread-safety</span></div>
<div class="line">        <span class="keywordflow">if</span> (m_thread.GetThreadId() != <a class="code hl_function" href="class_thread.html#aafe48fc7ef98b9e6adcf7b188a30e35a">Thread::GetCurrentThreadId</a>()) </div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Reinvoke StoreAsync(data) on m_thread context</span></div>
<div class="line">            <span class="keywordflow">return</span> <a class="code hl_function" href="namespacedmq.html#a65e308cc5f3e37d2f7f89c72b9744ae2">dmq::MakeDelegate</a>(<span class="keyword">this</span>, &amp;DataStore::StoreAsync, m_thread)(data);</div>
<div class="line">        }</div>
<div class="line">        m_data = data;  <span class="comment">// Data stored on m_thread context</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Data m_data;        <span class="comment">// Data storage</span></div>
<div class="line">    <a class="code hl_class" href="class_thread.html">Thread</a> m_thread;    <span class="comment">// Internal thread</span></div>
<div class="line">};</div>
<div class="ttc" id="aclass_thread_html_aafe48fc7ef98b9e6adcf7b188a30e35a"><div class="ttname"><a href="class_thread.html#aafe48fc7ef98b9e6adcf7b188a30e35a">Thread::GetCurrentThreadId</a></div><div class="ttdeci">static TaskHandle_t GetCurrentThreadId()</div><div class="ttdoc">Get the ID of the currently executing thread.</div><div class="ttdef"><b>Definition</b> freertos/Thread.cpp:62</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3"></a>
Overview</h1>
<p>In C++, a delegate function object encapsulates a callable entity, such as a function, method, or lambda, so it can be invoked later. A delegate is a type-safe wrapper around a callable function that allows it to be passed around, stored, or invoked at a later time, typically within different contexts or on different threads. Delegates are particularly useful for event-driven programming, callbacks, asynchronous APIs, or when you need to pass functions as arguments.</p>
<p>Originally published on CodeProject at <a href="https://www.codeproject.com/Articles/5277036/Asynchronous-Multicast-Delegates-in-Modern-Cpluspl">Asynchronous Multicast Delegates in Modern C++</a> with a perfect 5.0 article feedback rating.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Sync Delegates</h2>
<p>Synchronous delegates invoke the target function anonymously within the current execution context. No external library dependencies are required.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Async Delegates</h2>
<p>Asynchronous delegates support both non-blocking and blocking invocation modes, including optional timeouts. The library enables anonymous invocation of any callable target, regardless of the number or type of arguments, or the presence of a return value. All argument types are supported — including by value, pointers, pointer-to-pointer, and references. Smart pointer delegates prevents async invocation on destroyed target objects.</p>
<p>The delegate library abstracts the complexities of invoking functions across thread boundaries. Concrete examples are provided below, with straightforward paths to porting across platforms.</p>
<ul>
<li><b>Operating System:</b> Windows, Linux, <a href="https://github.com/FreeRTOS/FreeRTOS">FreeRTOS</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Remote Delegates</h2>
<p>Remote delegates enable function invocation across processes or processors using customizable serialization and transport mechanisms. All argument data is marshaled to support remote callables with any function signature. The design allows easy integration with new transport or serialization libraries. Concrete examples using supported libraries are provided below.</p>
<ul>
<li><b>Serialization:</b> <a href="https://msgpack.org/index.html">MessagePack</a>, <a href="https://github.com/Tencent/rapidjson">RapidJSON</a>, <a href="https://github.com/USCiLab/cereal">Cereal</a>, <a href="https://github.com/fraillt/bitsery">Bitsery</a>, <a href="https://github.com/endurodave/MessageSerialize">MessageSerialize</a></li>
<li><b>Transport:</b> <a href="https://zeromq.org/">ZeroMQ</a>, <a href="https://github.com/nanomsg/nng">NNG</a>, <a href="https://github.com/eclipse-paho/paho.mqtt.c">MQTT</a>, UDP, data pipe, memory buffer</li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Delegate Semantics and Use Cases</h2>
<p>It is always safe to call the delegate. In its null state, a call will not perform any action and will return a default-constructed return value. A delegate behaves like a normal pointer type: it can be copied, compared for equality, called, and compared to <code>nullptr</code>. Const correctness is maintained; stored const objects can only be called by const member functions.</p>
<p>A delegate instance can be:</p>
<ul>
<li>Copied freely.</li>
<li>Compared to same type delegates and <code>nullptr</code>.</li>
<li>Reassigned.</li>
<li>Called.</li>
</ul>
<p>Typical use cases are:</p>
<ul>
<li>Synchronous and Asynchronous Callbacks</li>
<li>Event-Driven Programming</li>
<li>Inter-Process and Inter-Processor Communication</li>
<li>Inter-Thread Publish/Subscribe (Observer) Pattern</li>
<li>Thread-Safe Asynchronous API</li>
<li>Asynchronous Method Invocation (AMI)</li>
<li>Design Patterns (Active Object)</li>
<li><code>std::async</code> <a class="el" href="class_thread.html" title="Cross-platform thread for any system supporting C++11 std::thread (e.g. Windows, Linux).">Thread</a> Targeting</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
Modular Architecture</h1>
<p>DelegateMQ uses an external thread, transport, and serializer, all of which are based on simple, well-defined interfaces.</p>
<p><img src="docs/LayerDiagram.jpg" alt="DelegateMQ Layer Diagram" style="width:70%;" class="inline"/><br  />
 <em>DelegateMQ Layer Diagram</em></p>
<p>The library's flexible CMake build options allow for the inclusion of only the necessary features. Synchronous, asynchronous, and remote delegates can be used individually or in combination.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Getting Started</h1>
<p>To build and run DelegateMQ, follow these simple steps. The library uses <a href="https://www.cmake.org">CMake</a> to generate build files and supports Visual Studio, GCC, and Clang toolchains.</p>
<ol type="1">
<li>Clone the repository.</li>
<li>From the repository root, run the following CMake command: <br  />
 <code>cmake -B build .</code></li>
<li>Build and run the project within the <code>build</code> directory.</li>
</ol>
<p>See <a href="docs/DETAILS.md#sample-projects">Sample Projects</a> to build other project examples. See <a href="docs/DETAILS.md#porting-guide">Porting Guide</a> for details on porting to a new platform.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Documentation</h1>
<ul>
<li>See Design Details for a <a href="docs/DETAILS.md#porting-guide">porting guide</a>, design documentation and <a href="docs/DETAILS.md#sample-projects">more examples</a>.</li>
<li>See <a href="https://endurodave.github.io/DelegateMQ/html/index.html">Doxygen Documentation</a> for source code documentation.</li>
<li>See <a href="https://app.codecov.io/gh/endurodave/DelegateMQ">Unit Test Code Coverage</a> test results.</li>
</ul>
<h1><a class="anchor" id="autotoc_md11"></a>
Motivation</h1>
<p>Systems are composed of various design patterns or libraries to implement callbacks, asynchronous APIs, and inter-thread or inter-processor communications. These elements typically lack shared commonality. Callbacks are one-off implementations by individual developers, messages between threads rely on OS message queues, and communication libraries handle data transfer complexities. However, the underlying commonality lies in the need to move argument data to the target handler function, regardless of its location.</p>
<p>The DelegateMQ middleware effectively encapsulates all data movement and function invocation within a single library. Whether the target function is a static method, class method, or lambda—residing locally in a separate thread or remotely on a different processor—the library ensures the movement of argument data (marshalling when necessary) and invokes the target function. The low-level details of data movement and function invocation are neatly abstracted from the application layer.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Features</h1>
<p>DelegateMQ at a glance.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category   </th><th class="markdownTableHeadNone">DelegateMQ    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Purpose   </td><td class="markdownTableBodyNone">Unify callable invocation across threads, processes, and networks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Usages   </td><td class="markdownTableBodyNone">Callbacks (synchronous and asynchronous), asynchronous API's, communication and data distribution, and more    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Library   </td><td class="markdownTableBodyNone">Allows customizing data sharing between threads, processes, or processors    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Object Lifetime   </td><td class="markdownTableBodyNone">Thread-safe management via smart pointers (<code>std::weak_ptr</code>) prevents async invocation on destroyed objects (no dangling pointers).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Complexity   </td><td class="markdownTableBodyNone">Lightweight and extensible through external library interfaces and full source code    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Threads   </td><td class="markdownTableBodyNone">No internal threads. External configurable thread interface portable to any OS (<code>IThread</code>).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Watchdog   </td><td class="markdownTableBodyNone">Configurable timeout to detect and handle unresponsive threads.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Multicast   </td><td class="markdownTableBodyNone">Broadcast invoke anonymous callable targets onto multiple threads    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Message Priority   </td><td class="markdownTableBodyNone">Asynchronous delegates support prioritization to ensure timely execution of critical messages    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Serialization   </td><td class="markdownTableBodyNone">External configurable serialization data formats, such as MessagePack, RapidJSON, or custom encoding (<code>ISerializer</code>)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Transport   </td><td class="markdownTableBodyNone">External configurable transport, such as ZeroMQ, TCP, UDP, serial, data pipe or any custom transport (<code><a class="el" href="class_i_transport.html" title="DelegateMQ transport interface.">ITransport</a></code>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Timeouts and Retries   </td><td class="markdownTableBodyNone">Provided by a communication library (e.g. ZeroMQ REQ-REP (Request-Reply)), TCP/IP stack, or custom solution (<code><a class="el" href="class_i_transport_monitor.html" title="DelegateMQ transport monitor interface.">ITransportMonitor</a></code>)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Message Buffering   </td><td class="markdownTableBodyNone">Remote delegate message buffering provided by a communication library (e.g. ZeroMQ) or custom solution within transport    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dynamic Memory   </td><td class="markdownTableBodyNone">Heap or DelegateMQ fixed-block allocator    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Debug Logging   </td><td class="markdownTableBodyNone">Debug logging using spdlog C++ logging library    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Error Handling   </td><td class="markdownTableBodyNone">Configurable for return error code, assert or exception    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Embedded Friendly   </td><td class="markdownTableBodyNone">Yes. Any OS such as Windows, Linux and FreeRTOS. An OS is not required (i.e. "super loop").    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Operation System   </td><td class="markdownTableBodyNone">Any. Custom <code>IThread</code> implementation may be required.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Language   </td><td class="markdownTableBodyNone">C++17 or higher   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md13"></a>
Alternative Implementations</h1>
<p>Alternative asynchronous implementations similar in concept to DelegateMQ, simpler, and less features.</p>
<ul>
<li><a href="https://github.com/endurodave/AsyncCallback">Asynchronous Callbacks in C++</a> - A C++ asynchronous callback framework.</li>
<li><a href="https://github.com/endurodave/C_AsyncCallback">Asynchronous Callbacks in C</a> - A C language asynchronous callback framework.</li>
</ul>
<h1><a class="anchor" id="autotoc_md14"></a>
Other Projects Using DelegateMQ</h1>
<p>Repositories utilizing the DelegateMQ library.</p>
<ul>
<li><a href="https://github.com/endurodave/StateMachineWithModernDelegates">C++ State Machine with Asynchronous Delegates</a> - a framework combining a C++ state machine with the asynchronous delegate library.</li>
<li><a href="https://github.com/endurodave/AsyncStateMachine">Asynchronous State Machine Design in C++</a> - an asynchronous C++ state machine implemented using an asynchronous delegate library.</li>
<li><a href="https://github.com/endurodave/IntegrationTestFramework">Integration Test Framework using Google Test and Delegates</a> - a multi-threaded C++ software integration test framework using Google Test and DelegateMQ libraries.</li>
<li><a href="https://github.com/endurodave/Async-SQLite">Asynchronous SQLite API using C++ Delegates</a> - an asynchronous SQLite wrapper implemented using an asynchronous delegate library. </li>
</ul>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
