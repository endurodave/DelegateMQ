<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Delegates: serialize Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Delegates
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classserialize.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classserialize-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">serialize Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The serialize class binary serializes and deserializes C++ objects.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="msg__serialize_8h_source.html">msg_serialize.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classserialize_1_1_i.html">I</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface that all serialized user defined classes inherit.  <a href="classserialize_1_1_i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9a6b840996a628f65126f216bafe3ab4" id="r_a9a6b840996a628f65126f216bafe3ab4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a6b840996a628f65126f216bafe3ab4">Type</a> { <br />
&#160;&#160;<a class="el" href="#a9a6b840996a628f65126f216bafe3ab4a696b031073e74bf2cb98e5ef201d4aa3">UNKNOWN</a> = 0
, <a class="el" href="#a9a6b840996a628f65126f216bafe3ab4aa0000d7769148184776f1d17656921b0">LITERAL</a> = 1
, <a class="el" href="#a9a6b840996a628f65126f216bafe3ab4a63b588d5559f64f89a416e656880b949">STRING</a> = 8
, <a class="el" href="#a9a6b840996a628f65126f216bafe3ab4ad002390d7727d576cef45267f1678ea3">WSTRING</a> = 9
, <br />
&#160;&#160;<a class="el" href="#a9a6b840996a628f65126f216bafe3ab4a87752381b583740610f1dfeb07fdad7e">VECTOR</a> = 20
, <a class="el" href="#a9a6b840996a628f65126f216bafe3ab4a5af1a3a285c2bdee4192223e31e1f833">MAP</a> = 21
, <a class="el" href="#a9a6b840996a628f65126f216bafe3ab4a298cb25408234de02baf2085803a464a">LIST</a> = 22
, <a class="el" href="#a9a6b840996a628f65126f216bafe3ab4a8c52684db8f49511e9b44471716bf164">SET</a> = 23
, <br />
&#160;&#160;<a class="el" href="#a9a6b840996a628f65126f216bafe3ab4a4d619e0e898184cd4c444d68c5e8cb35">ENDIAN</a> = 30
, <a class="el" href="#a9a6b840996a628f65126f216bafe3ab4a5123cb514ff95a726922950380866e00">USER_DEFINED</a> = 31
<br />
 }</td></tr>
<tr class="separator:a9a6b840996a628f65126f216bafe3ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb1afef8776c22530f83bec54ea89b0" id="r_acfb1afef8776c22530f83bec54ea89b0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfb1afef8776c22530f83bec54ea89b0">ParsingError</a> { <br />
&#160;&#160;<a class="el" href="#acfb1afef8776c22530f83bec54ea89b0ab50339a10e1de285ac99d4c3990b8693">NONE</a>
, <a class="el" href="#acfb1afef8776c22530f83bec54ea89b0a2f93918ef99e03b7b8e7230b2a28fb52">TYPE_MISMATCH</a>
, <a class="el" href="#acfb1afef8776c22530f83bec54ea89b0a778538f32afec1c04103343a92a7ff0f">STREAM_ERROR</a>
, <a class="el" href="#acfb1afef8776c22530f83bec54ea89b0a6a0751f8d7c5f4b4b0a9d315bcfb121b">STRING_TOO_LONG</a>
, <br />
&#160;&#160;<a class="el" href="#acfb1afef8776c22530f83bec54ea89b0aa75ed07cefcfe1eaac8fc31011440c95">CONTAINER_TOO_MANY</a>
, <a class="el" href="#acfb1afef8776c22530f83bec54ea89b0ac063281d4adc16ebccfec66aa885b4dd">INVALID_INPUT</a>
, <a class="el" href="#acfb1afef8776c22530f83bec54ea89b0a581953f6b20ad7f993b64b1dc632032e">END_OF_FILE</a>
<br />
 }</td></tr>
<tr class="separator:acfb1afef8776c22530f83bec54ea89b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c4014cb8480145899c1da3d837d26a" id="r_ac6c4014cb8480145899c1da3d837d26a"><td class="memItemLeft" align="right" valign="top">typedef void(*)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6c4014cb8480145899c1da3d837d26a">ErrorHandler</a>(<a class="el" href="#acfb1afef8776c22530f83bec54ea89b0">ParsingError</a> error, int line, const char *file)</td></tr>
<tr class="separator:ac6c4014cb8480145899c1da3d837d26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab305a895fd24eb4361929f57dd313ab5" id="r_ab305a895fd24eb4361929f57dd313ab5"><td class="memItemLeft" align="right" valign="top">typedef void(*)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab305a895fd24eb4361929f57dd313ab5">ParseHandler</a>(const std::type_info &amp;typeId, size_t size)</td></tr>
<tr class="separator:ab305a895fd24eb4361929f57dd313ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff42f6a0b2af926919e970a95492c122" id="r_aff42f6a0b2af926919e970a95492c122"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff42f6a0b2af926919e970a95492c122">serialize</a> ()=default</td></tr>
<tr class="separator:aff42f6a0b2af926919e970a95492c122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587c1fd9308681181e30579b9930539f" id="r_a587c1fd9308681181e30579b9930539f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a587c1fd9308681181e30579b9930539f">~serialize</a> ()=default</td></tr>
<tr class="separator:a587c1fd9308681181e30579b9930539f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1789bd444322bdd9154bd1b0f5bbb3fa" id="r_a1789bd444322bdd9154bd1b0f5bbb3fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1789bd444322bdd9154bd1b0f5bbb3fa">LE</a> ()</td></tr>
<tr class="separator:a1789bd444322bdd9154bd1b0f5bbb3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eceddf9316ef275c8f99aa6573d491" id="r_ac4eceddf9316ef275c8f99aa6573d491"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4eceddf9316ef275c8f99aa6573d491">readEndian</a> (std::istream &amp;is, bool &amp;littleEndian)</td></tr>
<tr class="separator:ac4eceddf9316ef275c8f99aa6573d491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c9d82a1dc13412f4b3ba74f5cbbf0a" id="r_a14c9d82a1dc13412f4b3ba74f5cbbf0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14c9d82a1dc13412f4b3ba74f5cbbf0a">writeEndian</a> (std::ostream &amp;os)</td></tr>
<tr class="separator:a14c9d82a1dc13412f4b3ba74f5cbbf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa1e7d4f910e89b3464a228da71d889" id="r_abfa1e7d4f910e89b3464a228da71d889"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfa1e7d4f910e89b3464a228da71d889">read</a> (std::istream &amp;is, <a class="el" href="classserialize_1_1_i.html">I</a> *t_)</td></tr>
<tr class="separator:abfa1e7d4f910e89b3464a228da71d889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddf28ce1a3bc4c1431958bb3f247392" id="r_abddf28ce1a3bc4c1431958bb3f247392"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abddf28ce1a3bc4c1431958bb3f247392">read</a> (std::istream &amp;is, std::string &amp;s)</td></tr>
<tr class="separator:abddf28ce1a3bc4c1431958bb3f247392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fbb7680534439df2b5deafc9b554f7" id="r_a21fbb7680534439df2b5deafc9b554f7"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21fbb7680534439df2b5deafc9b554f7">read</a> (std::istream &amp;is, std::wstring &amp;s)</td></tr>
<tr class="separator:a21fbb7680534439df2b5deafc9b554f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2822faff8129cc083a021d0f907742da" id="r_a2822faff8129cc083a021d0f907742da"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2822faff8129cc083a021d0f907742da">read</a> (std::istream &amp;is, char *str)</td></tr>
<tr class="separator:a2822faff8129cc083a021d0f907742da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d65463e884f779312f9f216aa8948c4" id="r_a1d65463e884f779312f9f216aa8948c4"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d65463e884f779312f9f216aa8948c4">read</a> (std::istream &amp;is, std::vector&lt; bool &gt; &amp;container)</td></tr>
<tr class="separator:a1d65463e884f779312f9f216aa8948c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69f92552e29b9c1c109d4baf9e06761" id="r_ac69f92552e29b9c1c109d4baf9e06761"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac69f92552e29b9c1c109d4baf9e06761">write</a> (std::ostream &amp;os, <a class="el" href="classserialize_1_1_i.html">I</a> *t_)</td></tr>
<tr class="separator:ac69f92552e29b9c1c109d4baf9e06761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4f30966f77d9cc149a3c9a24163987" id="r_a3e4f30966f77d9cc149a3c9a24163987"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e4f30966f77d9cc149a3c9a24163987">write</a> (std::ostream &amp;os, const std::string &amp;s)</td></tr>
<tr class="separator:a3e4f30966f77d9cc149a3c9a24163987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b1378cbf461f6f1fc5aae8ec73e827" id="r_aa5b1378cbf461f6f1fc5aae8ec73e827"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5b1378cbf461f6f1fc5aae8ec73e827">write</a> (std::ostream &amp;os, std::string &amp;s)</td></tr>
<tr class="separator:aa5b1378cbf461f6f1fc5aae8ec73e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeba8ec2d58bf47857033e99b98a5d7" id="r_a2aeba8ec2d58bf47857033e99b98a5d7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aeba8ec2d58bf47857033e99b98a5d7">write</a> (std::ostream &amp;os, const std::wstring &amp;s)</td></tr>
<tr class="separator:a2aeba8ec2d58bf47857033e99b98a5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b578e6261b76e2875f350bffb5f5ee" id="r_a46b578e6261b76e2875f350bffb5f5ee"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46b578e6261b76e2875f350bffb5f5ee">write</a> (std::ostream &amp;os, std::wstring &amp;s)</td></tr>
<tr class="separator:a46b578e6261b76e2875f350bffb5f5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0033ad24e058cf8247a804027f0c582d" id="r_a0033ad24e058cf8247a804027f0c582d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0033ad24e058cf8247a804027f0c582d">write</a> (std::ostream &amp;os, char *str)</td></tr>
<tr class="separator:a0033ad24e058cf8247a804027f0c582d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af672deeca8e4b5b6c28d3aa1c11b4453" id="r_af672deeca8e4b5b6c28d3aa1c11b4453"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af672deeca8e4b5b6c28d3aa1c11b4453">write</a> (std::ostream &amp;os, const char *str)</td></tr>
<tr class="separator:af672deeca8e4b5b6c28d3aa1c11b4453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49d2211a9fe6efe1455301324268955" id="r_aa49d2211a9fe6efe1455301324268955"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa49d2211a9fe6efe1455301324268955">write</a> (std::ostream &amp;os, std::vector&lt; bool &gt; &amp;container)</td></tr>
<tr class="separator:aa49d2211a9fe6efe1455301324268955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a67e482ed436425c40a85a44931aeb" id="r_aa5a67e482ed436425c40a85a44931aeb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5a67e482ed436425c40a85a44931aeb"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5a67e482ed436425c40a85a44931aeb">read</a> (std::istream &amp;is, T &amp;t_, bool readPrependedType=true)</td></tr>
<tr class="separator:aa5a67e482ed436425c40a85a44931aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721e2ccdd72b4def0087f84acdd565bc" id="r_a721e2ccdd72b4def0087f84acdd565bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a721e2ccdd72b4def0087f84acdd565bc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a721e2ccdd72b4def0087f84acdd565bc">write</a> (std::ostream &amp;os, T &amp;t_, bool prependType=true)</td></tr>
<tr class="separator:a721e2ccdd72b4def0087f84acdd565bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2e3766a7ed3a8c1fe6b2a111eb0621" id="r_a8a2e3766a7ed3a8c1fe6b2a111eb0621"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8a2e3766a7ed3a8c1fe6b2a111eb0621"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a2e3766a7ed3a8c1fe6b2a111eb0621">write</a> (std::ostream &amp;os, std::vector&lt; T &gt; &amp;container)</td></tr>
<tr class="separator:a8a2e3766a7ed3a8c1fe6b2a111eb0621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7171b666b34b757283abfe576f9266" id="r_aaa7171b666b34b757283abfe576f9266"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aaa7171b666b34b757283abfe576f9266"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa7171b666b34b757283abfe576f9266">read</a> (std::istream &amp;is, std::vector&lt; T &gt; &amp;container)</td></tr>
<tr class="separator:aaa7171b666b34b757283abfe576f9266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa0ec25eba8fcdb5a94f82b6f02a8b9" id="r_a5aa0ec25eba8fcdb5a94f82b6f02a8b9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5aa0ec25eba8fcdb5a94f82b6f02a8b9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5aa0ec25eba8fcdb5a94f82b6f02a8b9">write</a> (std::ostream &amp;os, std::vector&lt; T * &gt; &amp;container)</td></tr>
<tr class="separator:a5aa0ec25eba8fcdb5a94f82b6f02a8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3faa12fcc205adab7930686697e78cf" id="r_ae3faa12fcc205adab7930686697e78cf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae3faa12fcc205adab7930686697e78cf"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3faa12fcc205adab7930686697e78cf">read</a> (std::istream &amp;is, std::vector&lt; T * &gt; &amp;container)</td></tr>
<tr class="separator:ae3faa12fcc205adab7930686697e78cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb89c3e29e4acee823e9b6d27a89110" id="r_a9cb89c3e29e4acee823e9b6d27a89110"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class P &gt; </td></tr>
<tr class="memitem:a9cb89c3e29e4acee823e9b6d27a89110"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cb89c3e29e4acee823e9b6d27a89110">write</a> (std::ostream &amp;os, std::map&lt; K, V, P &gt; &amp;container)</td></tr>
<tr class="separator:a9cb89c3e29e4acee823e9b6d27a89110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae812a637ede2eae0b7d1c64a0a5b95d6" id="r_ae812a637ede2eae0b7d1c64a0a5b95d6"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class P &gt; </td></tr>
<tr class="memitem:ae812a637ede2eae0b7d1c64a0a5b95d6"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae812a637ede2eae0b7d1c64a0a5b95d6">read</a> (std::istream &amp;is, std::map&lt; K, V, P &gt; &amp;container)</td></tr>
<tr class="separator:ae812a637ede2eae0b7d1c64a0a5b95d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e01f869fd9e3d0ca3386c41d71f069d" id="r_a2e01f869fd9e3d0ca3386c41d71f069d"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class P &gt; </td></tr>
<tr class="memitem:a2e01f869fd9e3d0ca3386c41d71f069d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e01f869fd9e3d0ca3386c41d71f069d">write</a> (std::ostream &amp;os, std::map&lt; K, V *, P &gt; &amp;container)</td></tr>
<tr class="separator:a2e01f869fd9e3d0ca3386c41d71f069d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266c822d76377c47af581a1e566e0f58" id="r_a266c822d76377c47af581a1e566e0f58"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class P &gt; </td></tr>
<tr class="memitem:a266c822d76377c47af581a1e566e0f58"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a266c822d76377c47af581a1e566e0f58">read</a> (std::istream &amp;is, std::map&lt; K, V *, P &gt; &amp;container)</td></tr>
<tr class="separator:a266c822d76377c47af581a1e566e0f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166cf10c574605bf7acb04f62f0518d3" id="r_a166cf10c574605bf7acb04f62f0518d3"><td class="memTemplParams" colspan="2">template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a166cf10c574605bf7acb04f62f0518d3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a166cf10c574605bf7acb04f62f0518d3">write</a> (std::ostream &amp;os, std::set&lt; T, P &gt; &amp;container)</td></tr>
<tr class="separator:a166cf10c574605bf7acb04f62f0518d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e25f919cd84914efb020a0b4dfdffb5" id="r_a6e25f919cd84914efb020a0b4dfdffb5"><td class="memTemplParams" colspan="2">template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a6e25f919cd84914efb020a0b4dfdffb5"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e25f919cd84914efb020a0b4dfdffb5">read</a> (std::istream &amp;is, std::set&lt; T, P &gt; &amp;container)</td></tr>
<tr class="separator:a6e25f919cd84914efb020a0b4dfdffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ca1a1217ef1f692e2bb518231d0aa3" id="r_a96ca1a1217ef1f692e2bb518231d0aa3"><td class="memTemplParams" colspan="2">template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a96ca1a1217ef1f692e2bb518231d0aa3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a96ca1a1217ef1f692e2bb518231d0aa3">write</a> (std::ostream &amp;os, std::set&lt; T *, P &gt; &amp;container)</td></tr>
<tr class="separator:a96ca1a1217ef1f692e2bb518231d0aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b169aa2d3dbdfee2a235c9b3d9feaf" id="r_aa5b169aa2d3dbdfee2a235c9b3d9feaf"><td class="memTemplParams" colspan="2">template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:aa5b169aa2d3dbdfee2a235c9b3d9feaf"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5b169aa2d3dbdfee2a235c9b3d9feaf">read</a> (std::istream &amp;is, std::set&lt; T *, P &gt; &amp;container)</td></tr>
<tr class="separator:aa5b169aa2d3dbdfee2a235c9b3d9feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9599e3f4d50097636e18e2552465fcd0" id="r_a9599e3f4d50097636e18e2552465fcd0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9599e3f4d50097636e18e2552465fcd0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9599e3f4d50097636e18e2552465fcd0">write</a> (std::ostream &amp;os, std::list&lt; T &gt; &amp;container)</td></tr>
<tr class="separator:a9599e3f4d50097636e18e2552465fcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed523e011a4b1647a9b4d7f9b13b8b42" id="r_aed523e011a4b1647a9b4d7f9b13b8b42"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aed523e011a4b1647a9b4d7f9b13b8b42"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed523e011a4b1647a9b4d7f9b13b8b42">read</a> (std::istream &amp;is, std::list&lt; T &gt; &amp;container)</td></tr>
<tr class="separator:aed523e011a4b1647a9b4d7f9b13b8b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24b9c0d43d0b621af7db7ffd3b7b385" id="r_ab24b9c0d43d0b621af7db7ffd3b7b385"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab24b9c0d43d0b621af7db7ffd3b7b385"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab24b9c0d43d0b621af7db7ffd3b7b385">write</a> (std::ostream &amp;os, std::list&lt; T * &gt; &amp;container)</td></tr>
<tr class="separator:ab24b9c0d43d0b621af7db7ffd3b7b385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b92c1f1445329b010b7baee28ba750" id="r_a85b92c1f1445329b010b7baee28ba750"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a85b92c1f1445329b010b7baee28ba750"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a85b92c1f1445329b010b7baee28ba750">read</a> (std::istream &amp;is, std::list&lt; T * &gt; &amp;container)</td></tr>
<tr class="separator:a85b92c1f1445329b010b7baee28ba750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d4b612d403691b8829435f20293dd6" id="r_aa0d4b612d403691b8829435f20293dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0d4b612d403691b8829435f20293dd6">setErrorHandler</a> (<a class="el" href="#ac6c4014cb8480145899c1da3d837d26a">ErrorHandler</a> error_handler_)</td></tr>
<tr class="separator:aa0d4b612d403691b8829435f20293dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab404cbfd9d4728d8f90e82b2c9f72da6" id="r_ab404cbfd9d4728d8f90e82b2c9f72da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acfb1afef8776c22530f83bec54ea89b0">ParsingError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab404cbfd9d4728d8f90e82b2c9f72da6">getLastError</a> () const</td></tr>
<tr class="separator:ab404cbfd9d4728d8f90e82b2c9f72da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4621dcdc7de613159fa5b0c954cca389" id="r_a4621dcdc7de613159fa5b0c954cca389"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4621dcdc7de613159fa5b0c954cca389">clearLastError</a> ()</td></tr>
<tr class="separator:a4621dcdc7de613159fa5b0c954cca389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310603d2e501dcb2884f690b55a62965" id="r_a310603d2e501dcb2884f690b55a62965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a310603d2e501dcb2884f690b55a62965">setParseHandler</a> (<a class="el" href="#ab305a895fd24eb4361929f57dd313ab5">ParseHandler</a> parse_handler_)</td></tr>
<tr class="separator:a310603d2e501dcb2884f690b55a62965"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The serialize class binary serializes and deserializes C++ objects. </p>
<p>Each class need to implement the <a class="el" href="classserialize_1_1_i.html" title="Abstract interface that all serialized user defined classes inherit.">serialize::I</a> abstract interface to allow binary serialization to any stream. A default constructor is required for the serialized object. Most container elements can be stored by value or by pointer. C++ containers supported are: </p><pre class="fragment">vector
list
map
set
string
wstring
char[]
</pre><p>Always check the input stream or output stream to ensure no errors before using data. e.g.</p>
<p>if (ss.good()) // Do something with input or output data</p>
<p>This serialization class is not thread safe and a serialie instance should only be accessed from a single task.</p>
<p>The serialize class support receiving objects that have more or less data fields that what is currenting being parsed. If more data is received after parsing an object, the extra data is discard. If less data is received, the parsing of the extra data fields does not occur. This supports the protocol changing by adding new data elements to an object. Once the protocol is released at a particular version, new data elements can be added but existing ones cannot be removed/changed. <br  />
 </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac6c4014cb8480145899c1da3d837d26a" name="ac6c4014cb8480145899c1da3d837d26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c4014cb8480145899c1da3d837d26a">&#9670;&#160;</a></span>ErrorHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(*) serialize::ErrorHandler(<a class="el" href="#acfb1afef8776c22530f83bec54ea89b0">ParsingError</a> error, int line, const char *file)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab305a895fd24eb4361929f57dd313ab5" name="ab305a895fd24eb4361929f57dd313ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab305a895fd24eb4361929f57dd313ab5">&#9670;&#160;</a></span>ParseHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(*) serialize::ParseHandler(const std::type_info &amp;typeId, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="acfb1afef8776c22530f83bec54ea89b0" name="acfb1afef8776c22530f83bec54ea89b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb1afef8776c22530f83bec54ea89b0">&#9670;&#160;</a></span>ParsingError</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#acfb1afef8776c22530f83bec54ea89b0">serialize::ParsingError</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acfb1afef8776c22530f83bec54ea89b0ab50339a10e1de285ac99d4c3990b8693" name="acfb1afef8776c22530f83bec54ea89b0ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfb1afef8776c22530f83bec54ea89b0a2f93918ef99e03b7b8e7230b2a28fb52" name="acfb1afef8776c22530f83bec54ea89b0a2f93918ef99e03b7b8e7230b2a28fb52"></a>TYPE_MISMATCH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfb1afef8776c22530f83bec54ea89b0a778538f32afec1c04103343a92a7ff0f" name="acfb1afef8776c22530f83bec54ea89b0a778538f32afec1c04103343a92a7ff0f"></a>STREAM_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfb1afef8776c22530f83bec54ea89b0a6a0751f8d7c5f4b4b0a9d315bcfb121b" name="acfb1afef8776c22530f83bec54ea89b0a6a0751f8d7c5f4b4b0a9d315bcfb121b"></a>STRING_TOO_LONG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfb1afef8776c22530f83bec54ea89b0aa75ed07cefcfe1eaac8fc31011440c95" name="acfb1afef8776c22530f83bec54ea89b0aa75ed07cefcfe1eaac8fc31011440c95"></a>CONTAINER_TOO_MANY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfb1afef8776c22530f83bec54ea89b0ac063281d4adc16ebccfec66aa885b4dd" name="acfb1afef8776c22530f83bec54ea89b0ac063281d4adc16ebccfec66aa885b4dd"></a>INVALID_INPUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfb1afef8776c22530f83bec54ea89b0a581953f6b20ad7f993b64b1dc632032e" name="acfb1afef8776c22530f83bec54ea89b0a581953f6b20ad7f993b64b1dc632032e"></a>END_OF_FILE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9a6b840996a628f65126f216bafe3ab4" name="a9a6b840996a628f65126f216bafe3ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6b840996a628f65126f216bafe3ab4">&#9670;&#160;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a9a6b840996a628f65126f216bafe3ab4">serialize::Type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4a696b031073e74bf2cb98e5ef201d4aa3" name="a9a6b840996a628f65126f216bafe3ab4a696b031073e74bf2cb98e5ef201d4aa3"></a>UNKNOWN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4aa0000d7769148184776f1d17656921b0" name="a9a6b840996a628f65126f216bafe3ab4aa0000d7769148184776f1d17656921b0"></a>LITERAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4a63b588d5559f64f89a416e656880b949" name="a9a6b840996a628f65126f216bafe3ab4a63b588d5559f64f89a416e656880b949"></a>STRING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4ad002390d7727d576cef45267f1678ea3" name="a9a6b840996a628f65126f216bafe3ab4ad002390d7727d576cef45267f1678ea3"></a>WSTRING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4a87752381b583740610f1dfeb07fdad7e" name="a9a6b840996a628f65126f216bafe3ab4a87752381b583740610f1dfeb07fdad7e"></a>VECTOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4a5af1a3a285c2bdee4192223e31e1f833" name="a9a6b840996a628f65126f216bafe3ab4a5af1a3a285c2bdee4192223e31e1f833"></a>MAP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4a298cb25408234de02baf2085803a464a" name="a9a6b840996a628f65126f216bafe3ab4a298cb25408234de02baf2085803a464a"></a>LIST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4a8c52684db8f49511e9b44471716bf164" name="a9a6b840996a628f65126f216bafe3ab4a8c52684db8f49511e9b44471716bf164"></a>SET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4a4d619e0e898184cd4c444d68c5e8cb35" name="a9a6b840996a628f65126f216bafe3ab4a4d619e0e898184cd4c444d68c5e8cb35"></a>ENDIAN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a6b840996a628f65126f216bafe3ab4a5123cb514ff95a726922950380866e00" name="a9a6b840996a628f65126f216bafe3ab4a5123cb514ff95a726922950380866e00"></a>USER_DEFINED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aff42f6a0b2af926919e970a95492c122" name="aff42f6a0b2af926919e970a95492c122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff42f6a0b2af926919e970a95492c122">&#9670;&#160;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">serialize::serialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a587c1fd9308681181e30579b9930539f" name="a587c1fd9308681181e30579b9930539f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587c1fd9308681181e30579b9930539f">&#9670;&#160;</a></span>~serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">serialize::~serialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4621dcdc7de613159fa5b0c954cca389" name="a4621dcdc7de613159fa5b0c954cca389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4621dcdc7de613159fa5b0c954cca389">&#9670;&#160;</a></span>clearLastError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serialize::clearLastError </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab404cbfd9d4728d8f90e82b2c9f72da6" name="ab404cbfd9d4728d8f90e82b2c9f72da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab404cbfd9d4728d8f90e82b2c9f72da6">&#9670;&#160;</a></span>getLastError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acfb1afef8776c22530f83bec54ea89b0">ParsingError</a> serialize::getLastError </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1789bd444322bdd9154bd1b0f5bbb3fa" name="a1789bd444322bdd9154bd1b0f5bbb3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1789bd444322bdd9154bd1b0f5bbb3fa">&#9670;&#160;</a></span>LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool serialize::LE </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if little endian. </p><dl class="section return"><dt>Returns</dt><dd>Returns true if little endian. <br  />
 </dd></dl>

</div>
</div>
<a id="a2822faff8129cc083a021d0f907742da" name="a2822faff8129cc083a021d0f907742da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2822faff8129cc083a021d0f907742da">&#9670;&#160;</a></span>read() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a character string from a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>- the character string to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="abfa1e7d4f910e89b3464a228da71d889" name="abfa1e7d4f910e89b3464a228da71d889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa1e7d4f910e89b3464a228da71d889">&#9670;&#160;</a></span>read() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classserialize_1_1_i.html">I</a> *</td>          <td class="paramname"><span class="paramname"><em>t_</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a user defined object implementing the serialize:<a class="el" href="classserialize_1_1_i.html" title="Abstract interface that all serialized user defined classes inherit.">I</a> interface from a stream. Normally the send and reciever object is the same size. However, if a newer version of the object is introduced on one side the sizes will differ. If received object is smaller than sent object, the extra data in the sent object is discarded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t_</td><td>- the object to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a85b92c1f1445329b010b7baee28ba750" name="a85b92c1f1445329b010b7baee28ba750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b92c1f1445329b010b7baee28ba750">&#9670;&#160;</a></span>read() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read into a list container from a stream. Items in list stored by pointer. Operator new called to create object instances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the list container to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="aed523e011a4b1647a9b4d7f9b13b8b42" name="aed523e011a4b1647a9b4d7f9b13b8b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed523e011a4b1647a9b4d7f9b13b8b42">&#9670;&#160;</a></span>read() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read into a list container from a stream. Items in list are stored by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the list container to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="a266c822d76377c47af581a1e566e0f58" name="a266c822d76377c47af581a1e566e0f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266c822d76377c47af581a1e566e0f58">&#9670;&#160;</a></span>read() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; K, V *, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read into a map container from a stream. Items in map stored by pointer. Operator new called to create object instances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the map container to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="ae812a637ede2eae0b7d1c64a0a5b95d6" name="ae812a637ede2eae0b7d1c64a0a5b95d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae812a637ede2eae0b7d1c64a0a5b95d6">&#9670;&#160;</a></span>read() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; K, V, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read into a map container from a stream. Items in map are stored by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the map container to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="aa5b169aa2d3dbdfee2a235c9b3d9feaf" name="aa5b169aa2d3dbdfee2a235c9b3d9feaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b169aa2d3dbdfee2a235c9b3d9feaf">&#9670;&#160;</a></span>read() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T *, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read into a set container from a stream. Items in set stored by pointer. Operator new called to create object instances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the set container to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="a6e25f919cd84914efb020a0b4dfdffb5" name="a6e25f919cd84914efb020a0b4dfdffb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e25f919cd84914efb020a0b4dfdffb5">&#9670;&#160;</a></span>read() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read into a set container from a stream. Items in set are stored by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the set container to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream <br  />
 </dd></dl>

</div>
</div>
<a id="abddf28ce1a3bc4c1431958bb3f247392" name="abddf28ce1a3bc4c1431958bb3f247392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abddf28ce1a3bc4c1431958bb3f247392">&#9670;&#160;</a></span>read() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a str::string from a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- the string to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="a1d65463e884f779312f9f216aa8948c4" name="a1d65463e884f779312f9f216aa8948c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d65463e884f779312f9f216aa8948c4">&#9670;&#160;</a></span>read() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a vector&lt;bool&gt; container from a stream. The vector&lt;bool&gt; items are stored differently and therefore need special handling to serialize. Unlike other specializations of vector, std::vector&lt;bool&gt; does not manage a dynamic array of bool objects. Instead, it is supposed to pack the boolean values into a single bit each. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the vector container to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="ae3faa12fcc205adab7930686697e78cf" name="ae3faa12fcc205adab7930686697e78cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3faa12fcc205adab7930686697e78cf">&#9670;&#160;</a></span>read() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read into a vector container from a stream. Items in vector stored by pointer. Operator new called to create object instances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the vector container to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="aaa7171b666b34b757283abfe576f9266" name="aaa7171b666b34b757283abfe576f9266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7171b666b34b757283abfe576f9266">&#9670;&#160;</a></span>read() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read into a vector container from a stream. Items in vector are stored by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the vector container to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="a21fbb7680534439df2b5deafc9b554f7" name="a21fbb7680534439df2b5deafc9b554f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fbb7680534439df2b5deafc9b554f7">&#9670;&#160;</a></span>read() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a str::wstring from a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- the string to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="aa5a67e482ed436425c40a85a44931aeb" name="aa5a67e482ed436425c40a85a44931aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a67e482ed436425c40a85a44931aeb">&#9670;&#160;</a></span>read() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t_</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>readPrependedType</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an object from a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>- the input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t_</td><td>- the object to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream </dd></dl>

</div>
</div>
<a id="ac4eceddf9316ef275c8f99aa6573d491" name="ac4eceddf9316ef275c8f99aa6573d491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4eceddf9316ef275c8f99aa6573d491">&#9670;&#160;</a></span>readEndian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; serialize::readEndian </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>littleEndian</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read endian from stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">istream</td><td>- input stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if little endian. </dd></dl>

</div>
</div>
<a id="aa0d4b612d403691b8829435f20293dd6" name="aa0d4b612d403691b8829435f20293dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d4b612d403691b8829435f20293dd6">&#9670;&#160;</a></span>setErrorHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serialize::setErrorHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac6c4014cb8480145899c1da3d837d26a">ErrorHandler</a></td>          <td class="paramname"><span class="paramname"><em>error_handler_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a310603d2e501dcb2884f690b55a62965" name="a310603d2e501dcb2884f690b55a62965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310603d2e501dcb2884f690b55a62965">&#9670;&#160;</a></span>setParseHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serialize::setParseHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab305a895fd24eb4361929f57dd313ab5">ParseHandler</a></td>          <td class="paramname"><span class="paramname"><em>parse_handler_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0033ad24e058cf8247a804027f0c582d" name="a0033ad24e058cf8247a804027f0c582d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0033ad24e058cf8247a804027f0c582d">&#9670;&#160;</a></span>write() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a character string to a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>- the character string to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="af672deeca8e4b5b6c28d3aa1c11b4453" name="af672deeca8e4b5b6c28d3aa1c11b4453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af672deeca8e4b5b6c28d3aa1c11b4453">&#9670;&#160;</a></span>write() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a const character string to a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>- the character string to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a3e4f30966f77d9cc149a3c9a24163987" name="a3e4f30966f77d9cc149a3c9a24163987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4f30966f77d9cc149a3c9a24163987">&#9670;&#160;</a></span>write() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a const std::string to a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- the string to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a2aeba8ec2d58bf47857033e99b98a5d7" name="a2aeba8ec2d58bf47857033e99b98a5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeba8ec2d58bf47857033e99b98a5d7">&#9670;&#160;</a></span>write() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a const str::wstring to a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- the string to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="ac69f92552e29b9c1c109d4baf9e06761" name="ac69f92552e29b9c1c109d4baf9e06761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69f92552e29b9c1c109d4baf9e06761">&#9670;&#160;</a></span>write() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classserialize_1_1_i.html">I</a> *</td>          <td class="paramname"><span class="paramname"><em>t_</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a user defined object implementing the serialize:<a class="el" href="classserialize_1_1_i.html" title="Abstract interface that all serialized user defined classes inherit.">I</a> interface to a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t_</td><td>- the object to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="ab24b9c0d43d0b621af7db7ffd3b7b385" name="ab24b9c0d43d0b621af7db7ffd3b7b385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24b9c0d43d0b621af7db7ffd3b7b385">&#9670;&#160;</a></span>write() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a list container to a stream. The items in list are stored by pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the list container to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a9599e3f4d50097636e18e2552465fcd0" name="a9599e3f4d50097636e18e2552465fcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9599e3f4d50097636e18e2552465fcd0">&#9670;&#160;</a></span>write() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a list container to a stream. The items in list are stored by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the list container to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a2e01f869fd9e3d0ca3386c41d71f069d" name="a2e01f869fd9e3d0ca3386c41d71f069d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e01f869fd9e3d0ca3386c41d71f069d">&#9670;&#160;</a></span>write() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; K, V *, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a map container to a stream. The items in map are stored by pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the map container to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a9cb89c3e29e4acee823e9b6d27a89110" name="a9cb89c3e29e4acee823e9b6d27a89110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb89c3e29e4acee823e9b6d27a89110">&#9670;&#160;</a></span>write() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; K, V, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a map container to a stream. The items in map are stored by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the map container to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a96ca1a1217ef1f692e2bb518231d0aa3" name="a96ca1a1217ef1f692e2bb518231d0aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ca1a1217ef1f692e2bb518231d0aa3">&#9670;&#160;</a></span>write() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T *, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a set container to a stream. The items in set are stored by pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the set container to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a166cf10c574605bf7acb04f62f0518d3" name="a166cf10c574605bf7acb04f62f0518d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166cf10c574605bf7acb04f62f0518d3">&#9670;&#160;</a></span>write() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a set container to a stream. The items in set are stored by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the set container to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="aa5b1378cbf461f6f1fc5aae8ec73e827" name="aa5b1378cbf461f6f1fc5aae8ec73e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b1378cbf461f6f1fc5aae8ec73e827">&#9670;&#160;</a></span>write() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a std::string to a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- the string to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="aa49d2211a9fe6efe1455301324268955" name="aa49d2211a9fe6efe1455301324268955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49d2211a9fe6efe1455301324268955">&#9670;&#160;</a></span>write() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a vector&lt;bool&gt; container to a stream. The vector&lt;bool&gt; items are stored differently and therefore need special handling to serialize. Unlike other specialisations of vector, std::vector&lt;bool&gt; does not manage a dynamic array of bool objects.Instead, it is supposed to pack the boolean values into a single bit each. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the vector container to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a5aa0ec25eba8fcdb5a94f82b6f02a8b9" name="a5aa0ec25eba8fcdb5a94f82b6f02a8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa0ec25eba8fcdb5a94f82b6f02a8b9">&#9670;&#160;</a></span>write() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a vector container to a stream. The items in vector are stored by pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the vector container to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a8a2e3766a7ed3a8c1fe6b2a111eb0621" name="a8a2e3766a7ed3a8c1fe6b2a111eb0621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2e3766a7ed3a8c1fe6b2a111eb0621">&#9670;&#160;</a></span>write() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a vector container to a stream. The items in vector are stored by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>- the vector container to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a46b578e6261b76e2875f350bffb5f5ee" name="a46b578e6261b76e2875f350bffb5f5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b578e6261b76e2875f350bffb5f5ee">&#9670;&#160;</a></span>write() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a str::wstring to a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- the string to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a721e2ccdd72b4def0087f84acdd565bc" name="a721e2ccdd72b4def0087f84acdd565bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721e2ccdd72b4def0087f84acdd565bc">&#9670;&#160;</a></span>write() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; serialize::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t_</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>prependType</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write an object to a stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>- the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t_</td><td>- the object to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a14c9d82a1dc13412f4b3ba74f5cbbf0a" name="a14c9d82a1dc13412f4b3ba74f5cbbf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c9d82a1dc13412f4b3ba74f5cbbf0a">&#9670;&#160;</a></span>writeEndian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serialize::writeEndian </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write current CPU endian to stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ostream</td><td>- output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="msg__serialize_8h_source.html">msg_serialize.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classserialize.html">serialize</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
